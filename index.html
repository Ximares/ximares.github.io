<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
<title>Ximares — Coin Collect Idle (8-bit Funk)</title>
<style>
  :root{
    --bg:#0f1724;
    --card:#0b1220;
    --accent:#ffcb6b;
    --muted:#9aa4b2;
    --glass:rgba(255,255,255,0.06);
    --radius:14px;
  }
  html,body{
    margin:0;
    height:100%;
    background:linear-gradient(180deg,var(--bg) 0%,#071021 100%);
    color:#e6eef8;
    font-family:Inter,system-ui,-apple-system,"Segoe UI",Roboto,Arial,sans-serif;
    -webkit-font-smoothing:antialiased;
  }
  body{
    overflow:auto;
  }
  .wrap{
    min-height:100vh;
    display:flex;
    align-items:center;
    justify-content:center;
    padding:16px;
    box-sizing:border-box;
  }
  .card{
    background:linear-gradient(180deg,var(--card),#050c17);
    border-radius:var(--radius);
    padding:16px;
    width:100%;
    max-width:1000px;
    box-shadow:0 12px 30px rgba(2,6,23,0.7);
    display:grid;
    grid-template-columns:minmax(0,2fr) minmax(0,1.3fr);
    gap:16px;
    max-height:calc(100vh - 32px);
    box-sizing:border-box;
  }
  header h1{margin:0;font-size:20px}
  header p{margin:4px 0 0;color:var(--muted);font-size:13px}

  .game-area{
    background:linear-gradient(180deg,rgba(255,255,255,0.02),transparent);
    border-radius:12px;
    padding:10px;
    display:flex;
    flex-direction:column;
    gap:8px;
  }
  canvas{
    width:100%;
    height:380px;
    background:radial-gradient(circle at 20% 15%,#10253c,#050d18);
    border-radius:10px;
    display:block;
    box-shadow:inset 0 1px 0 rgba(255,255,255,0.04);
    touch-action:none;
  }
  .controls{
    display:flex;
    flex-wrap:wrap;
    gap:8px;
    align-items:center;
    justify-content:flex-start;
  }
  .btn{
    background:var(--glass);
    color:var(--muted);
    border-radius:10px;
    padding:8px 12px;
    font-size:13px;
    border:1px solid rgba(255,255,255,0.06);
    cursor:pointer;
  }
  .btn.primary{
    background:linear-gradient(90deg,#ffdd8a,#ffb84d);
    color:#071021;
    font-weight:700;
  }
  .stats{
    display:flex;
    gap:10px;
    flex-wrap:wrap;
    font-size:13px;
    color:var(--muted);
  }

  .info{
    padding:10px;
    border-radius:10px;
    background:linear-gradient(180deg,rgba(255,255,255,0.01),transparent);
    border:1px solid rgba(255,255,255,0.04);
    color:var(--muted);
    font-size:13px;
  }

  .col-right{
    display:flex;
    flex-direction:column;
    gap:10px;
    overflow:hidden;
  }

  .upgrades-panel{
    flex:1;
    min-height:0;
    display:flex;
    flex-direction:column;
  }
  .upgrades-panel-inner{
    flex:1;
    min-height:0;
    overflow:auto;
  }
  .upgrade-list{
    list-style:none;
    padding:0;
    margin:0;
  }
  .upgrade-list li{
    display:flex;
    justify-content:space-between;
    align-items:center;
    gap:6px;
    padding:6px 0;
    border-bottom:1px solid rgba(255,255,255,0.04);
    font-size:13px;
  }
  .upgrade-btn{
    padding:4px 8px;
    border-radius:8px;
    border:none;
    background:var(--glass);
    color:var(--muted);
    cursor:pointer;
    font-size:12px;
  }
  .upgrade-btn:disabled{
    opacity:0.4;
    cursor:default;
  }

  footer{
    grid-column:1/-1;
    text-align:center;
    color:var(--muted);
    font-size:11px;
    margin-top:4px;
  }

  .scroll-toggle{
    position:fixed;
    top:10px;
    right:10px;
    z-index:9999;
    padding:8px 10px;
    border-radius:10px;
    background:#ffd28c;
    color:#031021;
    border:none;
    font-size:12px;
    font-weight:700;
    box-shadow:0 6px 18px rgba(0,0,0,0.4);
    cursor:pointer;
  }

  /* bottom-sheet style upgrades for small screens */
  @media (max-width:800px){
    .card{
      grid-template-columns:minmax(0,1fr);
      max-height:none;
      height:auto;
    }
    .col-right{
      position:fixed;
      left:0;right:0;
      bottom:0;
      z-index:9000;
      pointer-events:none; /* allow clicks only when open */
    }
    .upgrades-panel{
      pointer-events:auto;
      max-height:40vh;
      transform:translateY(100%);
      transition:transform 0.2s ease-out;
      margin:0 10px 10px;
    }
    .upgrades-panel.open{
      transform:translateY(0%);
    }
  }

  @media (min-width:801px){
    #toggleUpgrades{
      display:none;
    }
  }
</style>
</head>
<body>
<button id="scrollToggle" class="scroll-toggle" aria-pressed="false">Disable Scrolling (Game Mode)</button>

<div class="wrap">
  <main class="card" aria-labelledby="title">
    <div>
      <header>
        <h1 id="title">Ximares — Coin Collect Idle (8-bit Funk)</h1>
        <p>Collect coins, build towers and upgrades. Chiptune music, anime :3 hero, and idle coins.</p>
      </header>

      <section class="game-area" aria-label="Game">
        <canvas id="gameCanvas" width="960" height="540"></canvas>

        <div class="controls">
          <button id="startBtn" class="btn primary">Start / Restart</button>
          <button id="pauseBtn" class="btn">Pause</button>
          <button id="muteBtn" class="btn">Mute Music</button>
          <button id="toggleUpgrades" class="btn">Upgrades (U)</button>
          <div class="stats">
            <span>Score: <strong id="score">0</strong></span>
            <span>Lives: <strong id="lives">3</strong></span>
            <span>Time: <span id="time">0s</span></span>
            <span>Banked: <span id="banked">0</span></span>
          </div>
        </div>

        <div class="info">
          <strong>How to play</strong>
          <p style="margin:4px 0 0">
            Move with Arrow keys / WASD or drag / tap. Collect coins (+10), avoid enemies. Idle upgrades give passive coins.
            Towers shoot enemies — tougher enemies need multiple hits.
            Press <b>U</b> or tap <b>Upgrades</b> to open the upgrades panel.
          </p>
        </div>
      </section>
    </div>

    <aside class="col-right">
      <section id="upgradesPanel" class="upgrades-panel info">
        <strong>Upgrades & Towers</strong>
        <div class="upgrades-panel-inner">
          <ul id="upgradeList" class="upgrade-list"></ul>
        </div>
      </section>
    </aside>

    <footer>Made for Ximares — Version 1.2 (8-bit, towers, HP & trails).</footer>
  </main>
</div>

<script>
(() => {
  /*** DOM ELEMENTS ***/
  const canvas = document.getElementById('gameCanvas');
  const ctx = canvas.getContext('2d');
  const startBtn = document.getElementById('startBtn');
  const pauseBtn = document.getElementById('pauseBtn');
  const muteBtn = document.getElementById('muteBtn');
  const scrollToggle = document.getElementById('scrollToggle');
  const toggleUpgradesBtn = document.getElementById('toggleUpgrades');
  const upgradesPanel = document.getElementById('upgradesPanel');
  const upgradeListEl = document.getElementById('upgradeList');
  const scoreEl = document.getElementById('score');
  const livesEl = document.getElementById('lives');
  const timeEl = document.getElementById('time');
  const bankedEl = document.getElementById('banked');

  /*** AUDIO (Web Audio 8-bit Funk) ***/
  const AudioContext = window.AudioContext || window.webkitAudioContext;
  let audioCtx = null;
  let musicGain, masterGain;
  let musicInterval = null;
  let musicVoices = [];
  let muted = false;

  function initAudio() {
    if (audioCtx) return;
    audioCtx = new AudioContext();
    masterGain = audioCtx.createGain();
    masterGain.gain.value = 0.6;
    masterGain.connect(audioCtx.destination);

    musicGain = audioCtx.createGain();
    musicGain.gain.value = 0.4;
    musicGain.connect(masterGain);

    create8bitMusic();
  }

  // Simple 8-bit funk: square wave bass + lead arpeggio
  function create8bitMusic() {
    // basic pentatonic scale frequencies
    const base = 110; // A2-ish bass
    const scale = [1, 1.25, 1.5, 2, 2.5]; // simple ratios
    // create two oscillators: bass + lead
    const bassOsc = audioCtx.createOscillator();
    bassOsc.type = 'square';
    const bassGain = audioCtx.createGain();
    bassGain.gain.value = 0.18;
    bassOsc.connect(bassGain).connect(musicGain);
    bassOsc.start();

    const leadOsc = audioCtx.createOscillator();
    leadOsc.type = 'square';
    const leadGain = audioCtx.createGain();
    leadGain.gain.value = 0.12;
    leadOsc.connect(leadGain).connect(musicGain);
    leadOsc.start();

    musicVoices = [ {osc:bassOsc,gain:bassGain}, {osc:leadOsc,gain:leadGain} ];

    // step through a pattern every 180ms
    const bassPattern = [0,0,2,0, 3,0,1,0];
    const leadPattern = [4,3,2,1, 2,3,4,1];
    let step = 0;

    if (musicInterval) clearInterval(musicInterval);
    musicInterval = setInterval(() => {
      if (!audioCtx || audioCtx.state !== 'running') return;
      const tNow = audioCtx.currentTime;

      const bi = bassPattern[step % bassPattern.length];
      const li = leadPattern[step % leadPattern.length];

      bassOsc.frequency.setValueAtTime(base*scale[bi], tNow);

      // small envelope for lead for 8-bit plucky effect
      leadGain.gain.cancelScheduledValues(tNow);
      leadGain.gain.setValueAtTime(0.001, tNow);
      leadGain.gain.exponentialRampToValueAtTime(0.16, tNow+0.01);
      leadGain.gain.exponentialRampToValueAtTime(0.01, tNow+0.17);
      leadOsc.frequency.setValueAtTime(base*2*scale[li], tNow);

      step++;
    }, 180);
  }

  function setMusicMuted(m) {
    muted = m;
    if (!musicGain) return;
    musicGain.gain.value = muted ? 0 : 0.4;
    muteBtn.textContent = muted ? 'Unmute Music' : 'Mute Music';
  }

  function coinSound() {
    if (!audioCtx) return;
    const t = audioCtx.currentTime;
    const osc = audioCtx.createOscillator();
    const g = audioCtx.createGain();
    osc.type = 'square';
    osc.frequency.setValueAtTime(1200, t);
    osc.frequency.exponentialRampToValueAtTime(400, t+0.12);
    g.gain.setValueAtTime(0.0001, t);
    g.gain.exponentialRampToValueAtTime(0.3, t+0.01);
    g.gain.exponentialRampToValueAtTime(0.0001, t+0.18);
    osc.connect(g).connect(masterGain);
    osc.start(t);
    osc.stop(t+0.2);
  }

  function hitSound() {
    if (!audioCtx) return;
    const t = audioCtx.currentTime;
    const osc = audioCtx.createOscillator();
    const g = audioCtx.createGain();
    osc.type = 'triangle';
    osc.frequency.setValueAtTime(500, t);
    osc.frequency.linearRampToValueAtTime(260, t+0.12);
    g.gain.setValueAtTime(0.001, t);
    g.gain.exponentialRampToValueAtTime(0.22, t+0.01);
    g.gain.exponentialRampToValueAtTime(0.001, t+0.16);
    osc.connect(g).connect(masterGain);
    osc.start(t);
    osc.stop(t+0.18);
  }

  /*** SCROLL TOGGLE ***/
  let scrollingEnabled = true;
  function applyScrollMode() {
    if (scrollingEnabled) {
      document.body.style.overflow = 'auto';
      canvas.style.touchAction = 'auto';
      scrollToggle.textContent = 'Disable Scrolling (Game Mode)';
      scrollToggle.setAttribute('aria-pressed','false');
    } else {
      document.body.style.overflow = 'hidden';
      canvas.style.touchAction = 'none';
      scrollToggle.textContent = 'Enable Scrolling';
      scrollToggle.setAttribute('aria-pressed','true');
    }
  }
  scrollToggle.addEventListener('click', () => {
    scrollingEnabled = !scrollingEnabled;
    applyScrollMode();
  });
  applyScrollMode();

  /*** GAME STATE ***/
  let cw = canvas.width, ch = canvas.height;
  const rectForCanvas = () => canvas.getBoundingClientRect();

  const state = {
    running:false,
    paused:false,
    startTime:0,
    lastFrame:0,
    elapsed:0,
    score:0,
    lives:3,
    banked:0,

    player:{
      x:480,y:270,radius:16,speed:230,
      lastX:480,lastY:270
    },

    coins:[],
    hazards:[],
    towers:[],
    arrows:[],
    keys:{},
    lastCoinSpawn:0,
    lastHazardSpawn:0,

    idleRate:0,
    towerFireRate:1.0,
    towerProjectileSpeed:320,
    towerRange:180,

    // for after-image trail
    trail:[],

    upgrades:[
      { id:'idle1', name:'Idle income +1/s', cost:50, type:'idle', amount:1 },
      { id:'speed1', name:'Speed ×1.25', cost:120, type:'speed', factor:1.25 },
      { id:'life1', name:'Extra Life +1', cost:200, type:'life', amount:1 },
      { id:'tower1', name:'Buy tower', cost:300, type:'tower' },
      { id:'firerate1', name:'Tower fire rate +20%', cost:180, type:'firerate', factor:1.2 },
      { id:'proj1', name:'Projectile speed +20%', cost:150, type:'projSpeed', factor:1.2 },
      { id:'range1', name:'Tower range +20%', cost:200, type:'range', factor:1.2 }
    ]
  };

  /*** UTILITIES ***/
  const rand = (a,b) => Math.random()*(b-a)+a;
  const clamp = (v,a,b) => Math.max(a,Math.min(b,v));
  const dist2 = (A,B) => {
    const dx=A.x-B.x, dy=A.y-B.y;
    return dx*dx+dy*dy;
  };

  function resize() {
    const ratio = window.devicePixelRatio || 1;
    const rectW = Math.min(960, Math.max(320, window.innerWidth - 40));
    const rectH = Math.min(560, Math.max(260, window.innerHeight*0.52));
    canvas.style.width = rectW + 'px';
    canvas.style.height = rectH + 'px';
    cw = rectW*ratio;
    ch = rectH*ratio;
    canvas.width = cw;
    canvas.height = ch;
    ctx.setTransform(ratio,0,0,ratio,0,0);
  }
  window.addEventListener('resize', resize);
  resize();

  /*** INPUT ***/
  window.addEventListener('keydown', e=>{
    state.keys[e.key.toLowerCase()] = true;
    if (e.key.toLowerCase() === 'u') toggleUpgrades();
  });
  window.addEventListener('keyup', e=>{
    state.keys[e.key.toLowerCase()] = false;
  });

  let pointerActive = false;
  canvas.addEventListener('pointerdown', (e)=>{
    if (!audioCtx) { initAudio(); audioCtx.resume && audioCtx.resume().catch(()=>{}); }
    if (!scrollingEnabled){
      pointerActive = true;
      movePlayerToPointer(e);
    }
  }, {passive:false});
  canvas.addEventListener('pointermove', (e)=>{
    if (pointerActive && !scrollingEnabled){
      movePlayerToPointer(e);
      e.preventDefault();
    }
  }, {passive:false});
  window.addEventListener('pointerup', ()=>pointerActive=false);

  function movePlayerToPointer(e){
    const r = rectForCanvas();
    const x = e.clientX - r.left;
    const y = e.clientY - r.top;
    state.player.x = clamp(x, state.player.radius, r.width - state.player.radius);
    state.player.y = clamp(y, state.player.radius, r.height - state.player.radius);
  }

  /*** SPAWNERS ***/
  function spawnCoin(){
    const r = rectForCanvas();
    state.coins.push({
      x:rand(25,r.width-25),
      y:rand(25,r.height-25),
      radius:8
    });
  }

  function spawnHazard(){
    const r = rectForCanvas();
    const roll = Math.random();
    let hp, radius, color;
    if (roll < 0.6){
      hp = 1; radius = 14; color = '#ff4b4b'; // basic red
    } else if (roll < 0.9){
      hp = 2; radius = 16; color = '#ff9f43'; // tougher orange
    } else {
      hp = 3; radius = 18; color = '#a855f7'; // tank purple
    }
    state.hazards.push({
      x:rand(radius,r.width-radius),
      y:rand(radius,r.height-radius),
      vx:rand(-80,80),
      vy:rand(-80,80),
      radius,
      hp,
      maxHp:hp,
      color
    });
  }

  /*** UPGRADES ***/
  function renderUpgrades(){
    upgradeListEl.innerHTML = '';
    state.upgrades.forEach(upg=>{
      const li = document.createElement('li');
      const left = document.createElement('div');
      left.textContent = `${upg.name} — Cost: ${upg.cost}`;
      const right = document.createElement('div');
      const btn = document.createElement('button');
      btn.className = 'upgrade-btn';
      btn.textContent = 'Buy';
      btn.disabled = Math.floor(state.banked) < upg.cost;
      btn.addEventListener('click',()=>buyUpgrade(upg));
      right.appendChild(btn);
      li.appendChild(left);
      li.appendChild(right);
      upgradeListEl.appendChild(li);
    });
  }

  function buyUpgrade(upg){
    if (Math.floor(state.banked) < upg.cost) return;
    state.banked -= upg.cost;
    switch(upg.type){
      case 'idle':
        state.idleRate += upg.amount;
        break;
      case 'speed':
        state.player.speed *= upg.factor;
        break;
      case 'life':
        state.lives += upg.amount;
        break;
      case 'tower':{
        const r = rectForCanvas();
        const tx = rand(60, r.width-60);
        const ty = rand(60, r.height-60);
        state.towers.push({x:tx,y:ty,lastShot:0});
        break;
      }
      case 'firerate':
        state.towerFireRate *= upg.factor;
        break;
      case 'projSpeed':
        state.towerProjectileSpeed *= upg.factor;
        break;
      case 'range':
        state.towerRange *= upg.factor;
        break;
    }
    renderUpgrades();
    updateStats();
  }

  /*** UPGRADES PANEL TOGGLE ***/
  function toggleUpgrades(){
    // On small screens, it's a bottom sheet; on desktop it's always visible, but
    // tapping U can "flash" focus or simply do nothing. We'll just toggle a CSS class.
    upgradesPanel.classList.toggle('open');
  }
  toggleUpgradesBtn.addEventListener('click', toggleUpgrades);

  /*** TOWERS & ARROWS ***/
  function towersStep(dt, now){
    // towers firing
    for (const t of state.towers){
      // find nearest hazard in range
      let best = null;
      let bestDist = Infinity;
      for (const h of state.hazards){
        const d = dist2(t,h);
        if (d < bestDist && d < state.towerRange*state.towerRange){
          bestDist = d;
          best = h;
        }
      }
      if (!best) continue;
      const cooldown = 800 / state.towerFireRate; // ms
      if (now - (t.lastShot||0) >= cooldown){
        t.lastShot = now;
        const ang = Math.atan2(best.y - t.y, best.x - t.x);
        state.arrows.push({
          x:t.x, y:t.y,
          vx:Math.cos(ang)*state.towerProjectileSpeed,
          vy:Math.sin(ang)*state.towerProjectileSpeed,
          radius:5
        });
      }
    }
    // move arrows
    for (let i=state.arrows.length-1;i>=0;i--){
      const a = state.arrows[i];
      a.x += a.vx*dt;
      a.y += a.vy*dt;
      if (a.x<0 || a.x>canvas.clientWidth || a.y<0 || a.y>canvas.clientHeight){
        state.arrows.splice(i,1);
        continue;
      }
      // collision vs hazards
      let hitSomething = false;
      for (let j=state.hazards.length-1;j>=0;j--){
        const h = state.hazards[j];
        if (dist2(a,h) < (a.radius + h.radius)**2){
          // 1 damage
          h.hp -= 1;
          hitSound();
          if (h.hp <= 0){
            state.hazards.splice(j,1);
            state.score += 5 * h.maxHp; // reward bonus for tougher enemies
          }
          state.arrows.splice(i,1);
          hitSomething = true;
          break;
        }
      }
      if (hitSomething) continue;
    }
  }

  /*** MAIN UPDATE ***/
  function update(dt, now){
    // input movement
    const p = state.player;
    const prevX = p.x, prevY = p.y;
    let dx=0,dy=0;
    if (state.keys['arrowleft']||state.keys['a']) dx-=1;
    if (state.keys['arrowright']||state.keys['d']) dx+=1;
    if (state.keys['arrowup']||state.keys['w']) dy-=1;
    if (state.keys['arrowdown']||state.keys['s']) dy+=1;
    if (dx!==0 || dy!==0){
      const len = Math.hypot(dx,dy)||1;
      p.x += (dx/len)*p.speed*dt;
      p.y += (dy/len)*p.speed*dt;
    }
    const r = rectForCanvas();
    p.x = clamp(p.x, p.radius, r.width - p.radius);
    p.y = clamp(p.y, p.radius, r.height - p.radius);

    // after-image trail when moving
    const moveDist2 = (p.x-prevX)**2 + (p.y-prevY)**2;
    if (moveDist2 > 1){ // if moved meaningfully
      state.trail.push({x:p.x,y:p.y,life:1.0});
    }
    for (let i=state.trail.length-1;i>=0;i--){
      state.trail[i].life -= dt*4; // fade speed
      if (state.trail[i].life <= 0) state.trail.splice(i,1);
    }

    // hazards movement
    for (const h of state.hazards){
      h.x += h.vx*dt;
      h.y += h.vy*dt;
      if (h.x < h.radius || h.x > canvas.clientWidth - h.radius) h.vx *= -1;
      if (h.y < h.radius || h.y > canvas.clientHeight - h.radius) h.vy *= -1;
    }

    // idle coins
    state.banked += state.idleRate * dt;

    // spawn coins & hazards
    if (now - state.lastCoinSpawn > 900){
      spawnCoin();
      state.lastCoinSpawn = now;
    }
    if (now - state.lastHazardSpawn > 2400){
      spawnHazard();
      state.lastHazardSpawn = now;
    }

    // towers & projectiles
    towersStep(dt, now);

    // coin collisions with player
    for (let i=state.coins.length-1;i>=0;i--){
      const c = state.coins[i];
      if (dist2(p,c) < (p.radius + c.radius)**2){
        state.coins.splice(i,1);
        state.score += 10;
        state.banked += 10;
        if (audioCtx && !muted) coinSound();
      }
    }

    // hazard collisions with player
    for (let i=state.hazards.length-1;i>=0;i--){
      const h = state.hazards[i];
      if (dist2(p,h) < (p.radius + h.radius)**2){
        // remove hazard and damage player by 1 life
        state.hazards.splice(i,1);
        state.lives -= 1;
        if (state.lives <= 0){
          state.running = false;
          alert('Game Over — score: '+Math.floor(state.score)+' banked: '+Math.floor(state.banked));
          if (musicGain) musicGain.gain.value = 0;
        }
      }
    }

    updateStats();
  }

  /*** DRAW ***/
  function draw(){
    ctx.clearRect(0,0,canvas.clientWidth,canvas.clientHeight);

    // after-image trail (draw first)
    for (const t of state.trail){
      const alpha = t.life * 0.5;
      ctx.beginPath();
      ctx.arc(t.x, t.y, state.player.radius*0.9, 0, Math.PI*2);
      ctx.fillStyle = `rgba(100,200,255,${alpha})`;
      ctx.fill();
    }

    // coins
    for (const c of state.coins){
      ctx.beginPath();
      ctx.arc(c.x,c.y,c.radius,0,Math.PI*2);
      ctx.fillStyle = 'rgba(255,210,90,0.98)';
      ctx.fill();
      ctx.beginPath();
      ctx.arc(c.x-c.radius*0.3,c.y-c.radius*0.3,c.radius*0.4,0,Math.PI*2);
      ctx.fillStyle = 'rgba(255,255,255,0.35)';
      ctx.fill();
    }

    // hazards (with HP ring)
    for (const h of state.hazards){
      ctx.beginPath();
      ctx.arc(h.x,h.y,h.radius,0,Math.PI*2);
      ctx.fillStyle = h.color;
      ctx.fill();

      // HP ring: show remaining hp as arc
      if (h.maxHp > 1){
        const frac = h.hp / h.maxHp;
        ctx.beginPath();
        ctx.arc(h.x,h.y,h.radius+3,-Math.PI/2,-Math.PI/2 + frac*2*Math.PI);
        ctx.strokeStyle = 'rgba(255,255,255,0.8)';
        ctx.lineWidth = 2;
        ctx.stroke();
      }
    }

    // towers
    for (const t of state.towers){
      ctx.beginPath();
      ctx.arc(t.x,t.y,14,0,Math.PI*2);
      ctx.fillStyle = '#4ea5ff';
      ctx.fill();
      // subtle base
      ctx.beginPath();
      ctx.arc(t.x,t.y,20,0,Math.PI*2);
      ctx.strokeStyle = 'rgba(78,165,255,0.3)';
      ctx.lineWidth = 2;
      ctx.stroke();
    }

    // arrows
    for (const a of state.arrows){
      ctx.beginPath();
      ctx.arc(a.x,a.y,a.radius,0,Math.PI*2);
      ctx.fillStyle = '#cce6ff';
      ctx.fill();
    }

    // player with :3 anime face
    const p = state.player;
    ctx.beginPath();
    ctx.arc(p.x,p.y,p.radius,0,Math.PI*2);
    ctx.fillStyle = 'rgba(110,210,255,0.98)';
    ctx.fill();

    // Eyes
    ctx.fillStyle = '#071021';
    ctx.beginPath(); ctx.arc(p.x-6, p.y-4, 3, 0, Math.PI*2); ctx.fill();
    ctx.beginPath(); ctx.arc(p.x+6, p.y-4, 3, 0, Math.PI*2); ctx.fill();

    // :3 mouth (little wedge)
    ctx.beginPath();
    ctx.moveTo(p.x-4, p.y+5);
    ctx.lineTo(p.x,   p.y+8);
    ctx.lineTo(p.x+4, p.y+5);
    ctx.strokeStyle = '#071021';
    ctx.lineWidth = 1.6;
    ctx.lineCap = 'round';
    ctx.stroke();
  }

  /*** STATS ***/
  function updateStats(){
    scoreEl.textContent = Math.floor(state.score);
    livesEl.textContent = state.lives;
    bankedEl.textContent = Math.floor(state.banked);
  }

  /*** LOOP ***/
  function loop(now){
    if (!state.running || state.paused) return;
    if (!state.lastFrame) state.lastFrame = now;
    const dt = Math.min(0.06, (now - state.lastFrame)/1000);
    state.lastFrame = now;
    state.elapsed = now - state.startTime;
    timeEl.textContent = Math.floor(state.elapsed/1000)+'s';

    update(dt, now);
    draw();
    requestAnimationFrame(loop);
  }

  /*** BUTTONS / START / PAUSE ***/
  startBtn.addEventListener('click', () => {
    if (!audioCtx){ initAudio(); audioCtx.resume && audioCtx.resume().catch(()=>{}); }
    state.running = true;
    state.paused = false;
    state.score = 0;
    state.lives = 3;
    state.banked = 0;
    state.coins = [];
    state.hazards = [];
    state.towers = [];
    state.arrows = [];
    state.trail = [];
    state.idleRate = 0;
    state.towerFireRate = 1.0;
    state.towerProjectileSpeed = 320;
    state.towerRange = 180;

    const r = rectForCanvas();
    state.player.x = r.width/2;
    state.player.y = r.height/2;
    state.player.lastX = state.player.x;
    state.player.lastY = state.player.y;

    state.startTime = performance.now();
    state.lastFrame = state.startTime;
    state.lastCoinSpawn = 0;
    state.lastHazardSpawn = 0;

    for (let i=0;i<3;i++) spawnCoin();
    spawnHazard();

    renderUpgrades();
    updateStats();
    if (musicGain && !muted) musicGain.gain.value = 0.4;
    requestAnimationFrame(loop);
  });

  pauseBtn.addEventListener('click', ()=>{
    if (!state.running) return;
    state.paused = !state.paused;
    if (!state.paused){
      state.lastFrame = performance.now();
      if (musicGain && !muted) musicGain.gain.value = 0.4;
      requestAnimationFrame(loop);
    } else {
      if (musicGain) musicGain.gain.value = 0;
    }
  });

  muteBtn.addEventListener('click', ()=>{
    if (!audioCtx){ initAudio(); audioCtx.resume && audioCtx.resume().catch(()=>{}); }
    setMusicMuted(!muted);
  });

  // initial
  renderUpgrades();
  updateStats();
})();
</script>
</body>
</html>
