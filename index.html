<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1, user-scalable=no" />
<title>Ximares — Coin Collect Idle (with audio)</title>
<style>
  :root{
    --bg:#0f1724; --card:#0b1220; --accent:#ffcb6b; --muted:#9aa4b2; --glass:rgba(255,255,255,0.04); --radius:14px;
  }
  html,body{height:100%; margin:0; background:linear-gradient(180deg,var(--bg) 0%, #071021 100%); color:#e6eef8; font-family:Inter,system-ui,-apple-system,"Segoe UI",Roboto,Arial;}
  .wrap{min-height:100%; display:flex; align-items:center; justify-content:center; padding:28px; box-sizing:border-box;}
  .card{background:linear-gradient(180deg,var(--card), #06111b); border-radius:var(--radius); padding:18px; width:100%; max-width:1000px; box-shadow:0 12px 30px rgba(2,6,23,0.6); display:grid; grid-template-columns:520px 1fr; gap:18px; align-items:start;}
  header h1{margin:0;font-size:20px}
  header p{margin:6px 0 0;color:var(--muted);font-size:13px}
  .game-area{background:linear-gradient(180deg, rgba(255,255,255,0.02), transparent); border-radius:12px; padding:12px; display:flex; flex-direction:column; gap:10px; align-items:center;}
  canvas{width:100%; height:420px; background:linear-gradient(180deg,#0a1726,#06121a); border-radius:10px; display:block; box-shadow: inset 0 1px 0 rgba(255,255,255,0.02); touch-action:none;}
  .controls{display:flex; gap:8px; align-items:center; justify-content:center; flex-wrap:wrap}
  .btn{background:var(--glass); color:var(--muted); border-radius:10px; padding:8px 12px; font-size:14px; border:1px solid rgba(255,255,255,0.03); cursor:pointer}
  .btn.primary{background:linear-gradient(90deg,#ffdd8a,#ffb84d); color:#071021; font-weight:700}
  .stats{display:flex; gap:10px; align-items:center; color:var(--muted); font-size:14px; flex-wrap:wrap}
  .info{padding:12px; border-radius:10px; background:linear-gradient(180deg, rgba(255,255,255,0.01), transparent); border:1px solid rgba(255,255,255,0.02); color:var(--muted); font-size:13px;}
  .col-right{display:flex; flex-direction:column; gap:12px}
  footer{grid-column:1/-1;text-align:center;color:var(--muted);font-size:12px;margin-top:8px}
  .upgrade-list{list-style:none;padding:0;margin:0}
  .upgrade-list li{display:flex; align-items:center; justify-content:space-between; gap:8px; padding:6px 0; border-bottom:1px dashed rgba(255,255,255,0.02)}
  .upgrade-btn{padding:6px 8px; border-radius:8px; border:none; background:var(--glass); color:var(--muted); cursor:pointer}
  .top-controls{display:flex; gap:8px; justify-content:flex-end}
  .scroll-toggle{position:fixed; top:12px; right:12px; z-index:9999; padding:8px 10px; border-radius:10px; background:#ffd28c; color:#031021; border:none; font-weight:700; box-shadow:0 6px 18px rgba(0,0,0,0.4); cursor:pointer}
  @media (max-width:980px){ .card{grid-template-columns:1fr; max-width:760px;} canvas{height:360px} .scroll-toggle{right:8px; top:8px} }
</style>
</head>
<body>
<button id="scrollToggle" class="scroll-toggle" aria-pressed="true">Disable Scrolling (Game Mode)</button>

<div class="wrap">
  <main class="card" aria-labelledby="title">
    <div>
      <header>
        <h1 id="title">Ximares — Coin Collect Idle (Audio + Towers)</h1>
        <p>Collect coins, buy upgrades & towers. Works on desktop and mobile. Music & sounds are generated locally for instant playback.</p>
      </header>

      <section class="game-area" aria-label="Game">
        <canvas id="gameCanvas" width="960" height="540" role="img" aria-label="Coin collect game canvas"></canvas>

        <div class="controls">
          <button id="startBtn" class="btn primary">Start / Restart</button>
          <button id="pauseBtn" class="btn">Pause</button>
          <button id="muteBtn" class="btn">Mute Music</button>
          <div class="stats">
            <div>Score: <strong id="score">0</strong></div>
            <div>Lives: <strong id="lives">0</strong></div>
            <div>Time: <span id="time">0s</span></div>
            <div>Banked: <span id="banked">0</span></div>
          </div>
        </div>

        <div class="info">
          <strong>How to play</strong>
          <p style="margin:6px 0 0">Move with Arrow keys / WASD or drag/tap on mobile. Collect coins (+10 each). Coins are added to your bank automatically; buy upgrades & towers from the right panel. Towers will shoot hazards.</p>
        </div>
      </section>
    </div>

    <aside class="col-right">
      <div class="info">
        <strong>Upgrades & Towers</strong>
        <ul id="upgradeList" class="upgrade-list"></ul>
      </div>

      <div class="info">
        <strong>Notes</strong>
        <p class="small" style="margin:6px 0 0">Sound is generated locally — click anywhere in the page (or press Start) to allow audio on some browsers. Use the scroll toggle at top-right to enable/disable page scrolling while playing.</p>
      </div>
    </aside>

    <footer>Made for Ximares — upgraded demo. Version 1.1</footer>
  </main>
</div>

<script>
/*
  Full single-file game:
  - Fix upgrade buy bug
  - Add towers that shoot hazards; projectile hits remove hazards
  - Tower upgrades: fire rate, projectile speed, range, more towers
  - WebAudio-generated coin sound and background music
  - Scroll toggle button for enabling/disabling page scroll
  - Touch handling that prevents scrolling when desired
*/

(() => {
  // DOM elements
  const canvas = document.getElementById('gameCanvas');
  const ctx = canvas.getContext('2d');
  const startBtn = document.getElementById('startBtn');
  const pauseBtn = document.getElementById('pauseBtn');
  const muteBtn = document.getElementById('muteBtn');
  const scoreEl = document.getElementById('score');
  const livesEl = document.getElementById('lives');
  const timeEl = document.getElementById('time');
  const bankedEl = document.getElementById('banked');
  const upgradeListEl = document.getElementById('upgradeList');
  const scrollToggle = document.getElementById('scrollToggle');

  // audio (WebAudio API)
  const AudioContext = window.AudioContext || window.webkitAudioContext;
  let audioCtx = null;
  let musicGain = null;
  let musicNode = null;
  let musicPlaying = false;
  let muted = false;

  function ensureAudio() {
    if (audioCtx) return;
    audioCtx = new AudioContext();
    musicGain = audioCtx.createGain();
    musicGain.gain.value = 0.25;
    musicGain.connect(audioCtx.destination);
    // create a soft background pad + subtle pulse loop
    const osc = audioCtx.createOscillator();
    const lfo = audioCtx.createOscillator();
    const lfoGain = audioCtx.createGain();
    const filter = audioCtx.createBiquadFilter();

    osc.type = 'sine';
    osc.frequency.value = 110; // base tone
    osc.connect(filter);

    filter.type = 'lowpass';
    filter.frequency.value = 900;
    filter.Q.value = 0.6;
    filter.connect(musicGain);

    lfo.type = 'sine';
    lfo.frequency.value = 0.25; // slow amplitude modulation
    lfoGain.gain.value = 0.6;
    lfo.connect(lfoGain);
    lfoGain.connect(osc.frequency); // subtle pitch wobble

    osc.start();
    lfo.start();

    musicNode = { osc, lfo, lfoGain, filter };
    musicPlaying = true;
  }

  function toggleMusic() {
    if (!audioCtx) ensureAudio();
    if (audioCtx.state === 'suspended') audioCtx.resume();
    if (musicPlaying) {
      musicGain.gain.setValueAtTime(0, audioCtx.currentTime);
      musicPlaying = false;
      muteBtn.textContent = 'Play Music';
    } else {
      musicGain.gain.setValueAtTime(muted ? 0 : 0.25, audioCtx.currentTime);
      musicPlaying = true;
      muteBtn.textContent = 'Mute Music';
    }
  }

  // simple coin pickup "pluck" using WebAudio (no file)
  function playCoinSound() {
    if (!audioCtx) ensureAudio();
    const now = audioCtx.currentTime;
    const o = audioCtx.createOscillator();
    const g = audioCtx.createGain();
    const f = audioCtx.createBiquadFilter();
    o.type = 'square';
    o.frequency.value = 800 + Math.random() * 200;
    f.type = 'highpass';
    f.frequency.value = 200;
    g.gain.value = 0.0001;
    o.connect(f);
    f.connect(g);
    g.connect(audioCtx.destination);
    // quick envelope
    g.gain.setValueAtTime(0.0001, now);
    g.gain.exponentialRampToValueAtTime(0.25, now + 0.01);
    g.gain.exponentialRampToValueAtTime(0.0001, now + 0.22);
    o.start(now);
    o.stop(now + 0.24);
  }

  // small "hit" sound for hazard destroyed by tower
  function playHitSound() {
    if (!audioCtx) ensureAudio();
    const now = audioCtx.currentTime;
    const o = audioCtx.createOscillator();
    const g = audioCtx.createGain();
    o.type = 'sawtooth';
    o.frequency.value = 300 + Math.random() * 300;
    o.connect(g);
    g.connect(audioCtx.destination);
    g.gain.setValueAtTime(0.0001, now);
    g.gain.exponentialRampToValueAtTime(0.18, now + 0.01);
    g.gain.exponentialRampToValueAtTime(0.0001, now + 0.18);
    o.start(now);
    o.stop(now + 0.2);
  }

  muteBtn.addEventListener('click', () => {
    muted = !muted;
    if (musicGain) musicGain.gain.setValueAtTime(muted ? 0 : 0.25, audioCtx.currentTime);
    muteBtn.textContent = muted ? 'Unmute Music' : 'Mute Music';
  });

  // Scroll toggle behavior
  let scrollingEnabled = true;
  function applyScrollMode() {
    if (scrollingEnabled) {
      document.body.style.overflow = 'auto';
      canvas.style.touchAction = 'auto';
      scrollToggle.textContent = 'Disable Scrolling (Game Mode)';
      scrollToggle.setAttribute('aria-pressed', 'true');
    } else {
      document.body.style.overflow = 'hidden';
      canvas.style.touchAction = 'none';
      scrollToggle.textContent = 'Enable Scrolling';
      scrollToggle.setAttribute('aria-pressed', 'false');
    }
  }
  scrollToggle.addEventListener('click', () => {
    scrollingEnabled = !scrollingEnabled;
    applyScrollMode();
  });
  applyScrollMode();

  // game variables and state
  let cw = canvas.width, ch = canvas.height;
  const state = {
    running: false,
    paused: false,
    startTime: 0,
    lastFrame: 0,
    elapsed: 0,
    score: 0,
    lives: 3,
    banked: 0,
    player: { x: 480, y: 270, radius: 16, speed: 220 },
    coins: [],
    hazards: [],
    towers: [],
    arrows: [],
    keys: {},
    lastCoinSpawn: 0,
    lastHazardSpawn: 0,
    idleRate: 0,
    // upgrade list: cost and effect
    upgrades: [
      { id: 'idle1', name: 'Auto-clicker +1/s', cost: 50, type: 'idle', amount: 1 },
      { id: 'speed1', name: 'Speed Boost ×1.25', cost: 120, type: 'speed', factor: 1.25 },
      { id: 'life1', name: 'Extra Life +1', cost: 200, type: 'life', amount: 1 },
      { id: 'tower1', name: 'Buy Tower', cost: 300, type: 'tower', amount: 1 },
      { id: 'firerate1', name: 'Towers: Fire Rate +20%', cost: 180, type: 'firerate', factor: 1.2 },
      { id: 'proj1', name: 'Towers: Projectile Speed +20%', cost: 150, type: 'projSpeed', factor: 1.2 },
      { id: 'range1', name: 'Towers: Range +20%', cost: 200, type: 'range', factor: 1.2 },
    ],
    // tower defaults
    towerFireRate: 1.0, // shots per second baseline (actually used as a multiplier for cooldown calc)
    towerProjectileSpeed: 320,
    towerRange: 180
  };

  // responsive canvas crispness
  function resize() {
    const ratio = window.devicePixelRatio || 1;
    // fit to visual size but limit extremes
    const rectW = Math.min(960, Math.max(320, window.innerWidth - 64));
    const rectH = Math.min(640, Math.max(280, window.innerHeight * 0.55));
    canvas.style.width = rectW + 'px';
    canvas.style.height = rectH + 'px';
    cw = Math.round(rectW * ratio);
    ch = Math.round(rectH * ratio);
    canvas.width = cw;
    canvas.height = ch;
    ctx.setTransform(ratio, 0, 0, ratio, 0, 0);
  }
  window.addEventListener('resize', resize);
  resize();

  // helpers
  const rand = (a, b) => Math.random() * (b - a) + a;
  const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
  const dist2 = (A, B) => {
    const dx = A.x - B.x, dy = A.y - B.y;
    return dx*dx + dy*dy;
  };

  // input handlers
  window.addEventListener('keydown', e => { state.keys[e.key.toLowerCase()] = true; });
  window.addEventListener('keyup', e => { state.keys[e.key.toLowerCase()] = false; });

  let pointerActive = false;
  canvas.addEventListener('pointerdown', (e) => {
    // enable audio context on first user gesture reliably
    if (!audioCtx) { ensureAudio(); audioCtx.resume && audioCtx.resume().catch(()=>{}); }
    if (!scrollingEnabled) { pointerActive = true; movePlayerToPointer(e); }
  }, {passive:false});
  canvas.addEventListener('pointermove', (e) => {
    if (pointerActive && !scrollingEnabled) { movePlayerToPointer(e); e.preventDefault && e.preventDefault(); }
  }, {passive:false});
  window.addEventListener('pointerup', () => { pointerActive = false; });

  function movePlayerToPointer(e){
    const rect = canvas.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;
    state.player.x = clamp(x, state.player.radius, rect.width - state.player.radius);
    state.player.y = clamp(y, state.player.radius, rect.height - state.player.radius);
  }

  // spawn helpers
  function spawnCoin(){
    const g = canvas.getBoundingClientRect();
    state.coins.push({ x: rand(30, g.width - 30), y: rand(30, g.height - 30), r: 8 });
  }
  function spawnHazard(){
    const g = canvas.getBoundingClientRect();
    state.hazards.push({
      x: rand(30, g.width - 30),
      y: rand(30, g.height - 30),
      r: 14,
      vx: rand(-80,80),
      vy: rand(-80,80)
    });
  }

  // upgrades UI & buy logic (bug fix: directly use upg object and update state immediately)
  function renderUpgrades() {
    upgradeListEl.innerHTML = '';
    state.upgrades.forEach(u => {
      const li = document.createElement('li');
      const left = document.createElement('div');
      left.textContent = `${u.name} — Cost: ${u.cost}`;
      const right = document.createElement('div');
      const btn = document.createElement('button');
      btn.className = 'upgrade-btn';
      btn.textContent = 'Buy';
      btn.disabled = (Math.floor(state.banked) < u.cost);
      btn.addEventListener('click', () => buyUpgrade(u));
      right.appendChild(btn);
      li.appendChild(left);
      li.appendChild(right);
      upgradeListEl.appendChild(li);
    });
  }

  function buyUpgrade(u) {
    // ensure integer-banked check
    if (Math.floor(state.banked) < u.cost) {
      // flash or small feedback could go here
      return;
    }
    // deduct cost and apply effect (immediately)
    state.banked -= u.cost;

    switch (u.type) {
      case 'idle':
        state.idleRate += u.amount;
        break;
      case 'speed':
        state.player.speed *= u.factor;
        break;
      case 'life':
        state.lives += u.amount;
        break;
      case 'tower':
        // spawn a tower at a safe random location
        const rect = canvas.getBoundingClientRect();
        const tx = rand(60, rect.width - 60);
        const ty = rand(60, rect.height - 60);
        state.towers.push({ x: tx, y: ty, lastShot: 0 });
        break;
      case 'firerate':
        state.towerFireRate *= u.factor;
        break;
      case 'projSpeed':
        state.towerProjectileSpeed *= u.factor;
        break;
      case 'range':
        state.towerRange *= u.factor;
        break;
      default:
        console.warn('Unknown upgrade', u);
    }

    // re-render UI so buy buttons update
    renderUpgrades();
    updateStats();
  }

  // towers: shoot arrows at nearest hazard
  function towerStep(dt, now) {
    // each tower tries to find nearest hazard and shoot if cooldown done
    for (const t of state.towers) {
      // find nearest hazard within range
      let best = null;
      let bestD = Infinity;
      for (const h of state.hazards) {
        const d = dist2(t, h);
        if (d < bestD && d < state.towerRange * state.towerRange) {
          bestD = d; best = h;
        }
      }
      if (!best) continue;
      // cooldown based on fire rate multiplier (higher fireRate -> shorter cooldown)
      const cooldown = 1000 / (state.towerFireRate * 1.0); // ms
      if (now - (t.lastShot || 0) > cooldown) {
        t.lastShot = now;
        // create arrow
        const angle = Math.atan2(best.y - t.y, best.x - t.x);
        state.arrows.push({
          x: t.x,
          y: t.y,
          vx: Math.cos(angle) * state.towerProjectileSpeed,
          vy: Math.sin(angle) * state.towerProjectileSpeed,
          r: 5
        });
      }
    }

    // update arrows and collision with hazards
    for (let i = state.arrows.length - 1; i >= 0; i--) {
      const a = state.arrows[i];
      a.x += a.vx * dt;
      a.y += a.vy * dt;
      // out of bounds cleanup
      if (a.x < 0 || a.x > canvas.clientWidth || a.y < 0 || a.y > canvas.clientHeight) {
        state.arrows.splice(i,1);
        continue;
      }
      // check collision with hazards
      let hit = false;
      for (let j = state.hazards.length - 1; j >= 0; j--) {
        const h = state.hazards[j];
        if (dist2(a,h) < (a.r + h.r) ** 2) {
          // remove hazard and arrow, play hit sound
          state.hazards.splice(j,1);
          state.arrows.splice(i,1);
          playHitSound();
          hit = true;
          break;
        }
      }
      if (hit) continue;
    }
  }

  // game update/draw
  function update(dt, now) {
    // player keyboard movement
    const p = state.player;
    let dx = 0, dy = 0;
    if (state.keys['arrowleft'] || state.keys['a']) dx -= 1;
    if (state.keys['arrowright'] || state.keys['d']) dx += 1;
    if (state.keys['arrowup'] || state.keys['w']) dy -= 1;
    if (state.keys['arrowdown'] || state.keys['s']) dy += 1;
    if (dx !== 0 || dy !== 0) {
      const len = Math.hypot(dx,dy) || 1;
      p.x += (dx/len) * p.speed * dt;
      p.y += (dy/len) * p.speed * dt;
    }
    // clamp to visible CSS pixels
    const rect = canvas.getBoundingClientRect();
    p.x = clamp(p.x, p.radius, rect.width - p.radius);
    p.y = clamp(p.y, p.radius, rect.height - p.radius);

    // hazards movement
    for (const h of state.hazards) {
      h.x += h.vx * dt;
      h.y += h.vy * dt;
      if (h.x < h.r) { h.x = h.r; h.vx *= -1; }
      if (h.y < h.r) { h.y = h.r; h.vy *= -1; }
      if (h.x > canvas.clientWidth - h.r) { h.x = canvas.clientWidth - h.r; h.vx *= -1; }
      if (h.y > canvas.clientHeight - h.r) { h.y = canvas.clientHeight - h.r; h.vy *= -1; }
    }

    // idle bank accumulation
    state.banked += state.idleRate * dt;

    // spawn logic
    if (now - state.lastCoinSpawn > 900) { spawnCoin(); state.lastCoinSpawn = now; }
    if (now - state.lastHazardSpawn > 2400) { spawnHazard(); state.lastHazardSpawn = now; }

    // tower logic
    towerStep(dt, now);

    // check player collisions with coins
    for (let i = state.coins.length - 1; i >= 0; i--) {
      const c = state.coins[i];
      if (dist2(p,c) < (p.radius + c.r) ** 2) {
        state.coins.splice(i,1);
        state.score += 10;
        state.banked += 10;
        playCoinSound();
      }
    }

    // hazards collide with player
    for (let i = state.hazards.length - 1; i >= 0; i--) {
      const h = state.hazards[i];
      if (dist2(p,h) < (p.radius + h.r) ** 2) {
        state.hazards.splice(i,1);
        state.lives -= 1;
        if (state.lives <= 0) {
          // stop game
          state.running = false;
          alert('Game Over — score: ' + Math.floor(state.score) + ', banked: ' + Math.floor(state.banked));
          // stop audio music but keep audio context
          if (musicPlaying && musicGain && audioCtx) musicGain.gain.setValueAtTime(0, audioCtx.currentTime);
        }
      }
    }

    // arrows handled in towerStep
    updateStats();
  }

  function draw() {
    ctx.clearRect(0,0,canvas.clientWidth, canvas.clientHeight);

    // coins
    for (const c of state.coins) {
      ctx.beginPath();
      ctx.arc(c.x, c.y, c.r, 0, Math.PI*2);
      ctx.fillStyle = 'rgba(255,200,80,0.98)';
      ctx.fill();
      // shine
      ctx.beginPath();
      ctx.arc(c.x - c.r*0.3, c.y - c.r*0.35, c.r*0.35, 0, Math.PI*2);
      ctx.fillStyle = 'rgba(255,255,255,0.35)';
      ctx.fill();
    }

    // hazards
    for (const h of state.hazards) {
      ctx.beginPath();
      ctx.arc(h.x, h.y, h.r, 0, Math.PI*2);
      ctx.fillStyle = 'rgba(220,80,80,0.95)';
      ctx.fill();
    }

    // towers
    for (const t of state.towers) {
      ctx.beginPath();
      ctx.arc(t.x, t.y, 14, 0, Math.PI*2);
      ctx.fillStyle = '#66bbff';
      ctx.fill();
      // range ring (subtle)
      ctx.beginPath();
      ctx.arc(t.x, t.y, state.towerRange, 0, Math.PI*2);
      ctx.strokeStyle = 'rgba(102,187,255,0.06)';
      ctx.lineWidth = 1;
      ctx.stroke();
    }

    // arrows
    for (const a of state.arrows) {
      ctx.beginPath();
      ctx.arc(a.x, a.y, a.r, 0, Math.PI*2);
      ctx.fillStyle = '#cce6ff';
      ctx.fill();
    }

    // player
    ctx.beginPath();
    ctx.arc(state.player.x, state.player.y, state.player.radius, 0, Math.PI*2);
    ctx.fillStyle = 'rgba(100,210,255,0.98)';
    ctx.fill();
    // eyes for personality
    ctx.fillStyle = '#071021';
    ctx.beginPath(); ctx.arc(state.player.x-6, state.player.y-4, 3, 0, Math.PI*2); ctx.fill();
    ctx.beginPath(); ctx.arc(state.player.x+4, state.player.y-4, 3, 0, Math.PI*2); ctx.fill();
  }

  // statistics update
  function updateStats() {
    scoreEl.textContent = Math.floor(state.score);
    livesEl.textContent = state.lives;
    bankedEl.textContent = Math.floor(state.banked);
  }

  // main loop
  function loop(now) {
    if (!state.running || state.paused) return;
    if (!state.lastFrame) state.lastFrame = now;
    const dt = Math.min(0.06, (now - state.lastFrame) / 1000);
    state.lastFrame = now;
    state.elapsed = now - state.startTime;
    timeEl.textContent = Math.floor(state.elapsed / 1000) + 's';

    update(dt, now);
    draw();

    requestAnimationFrame(loop);
  }

  // UI hooks
  startBtn.addEventListener('click', () => {
    // ensure audio is allowed
    if (!audioCtx) { ensureAudio(); try { audioCtx.resume(); } catch(e){} }
    state.running = true;
    state.paused = false;
    state.score = 0;
    state.lives = 3;
    state.banked = 0;
    state.player.x = canvas.clientWidth / 2;
    state.player.y = canvas.clientHeight / 2;
    state.coins = [];
    state.hazards = [];
    state.towers = [];
    state.arrows = [];
    state.lastFrame = performance.now();
    state.startTime = state.lastFrame;
    state.lastCoinSpawn = 0;
    state.lastHazardSpawn = 0;
    // pre-spawn some coins
    for (let i=0;i<4;i++) spawnCoin();
    renderUpgrades();
    updateStats();
    // unmute music on start if not muted
    if (!muted && audioCtx && musicGain) musicGain.gain.setValueAtTime(0.25, audioCtx.currentTime);
    requestAnimationFrame(loop);
  });

  pauseBtn.addEventListener('click', () => {
    state.paused = !state.paused;
    if (!state.paused) {
      state.lastFrame = performance.now();
      requestAnimationFrame(loop);
      if (!muted && musicGain) musicGain.gain.setValueAtTime(0.25, audioCtx.currentTime);
    } else {
      if (musicGain) musicGain.gain.setValueAtTime(0, audioCtx.currentTime);
    }
  });

  // initial UI render
  function renderUpgrades() {
    upgradeListEl.innerHTML = '';
    state.upgrades.forEach(u => {
      const li = document.createElement('li');
      li.style.display = 'flex';
      li.style.justifyContent = 'space-between';
      li.style.alignItems = 'center';
      const left = document.createElement('div');
      left.textContent = `${u.name} — Cost: ${u.cost}`;
      const right = document.createElement('div');
      const btn = document.createElement('button');
      btn.className = 'upgrade-btn';
      btn.textContent = 'Buy';
      btn.disabled = Math.floor(state.banked) < u.cost;
      btn.addEventListener('click', () => buyUpgrade(u));
      right.appendChild(btn);
      li.appendChild(left);
      li.appendChild(right);
      upgradeListEl.appendChild(li);
    });
  }

  // play a hit sound when tower kills hazard
  function playHitSound() {
    // small percussive tone
    playHitSoundImpl();
  }
  function playHitSoundImpl(){
    if (!audioCtx) ensureAudio();
    const now = audioCtx.currentTime;
    const o = audioCtx.createOscillator();
    const g = audioCtx.createGain();
    o.type = 'triangle';
    o.frequency.value = 420 + Math.random()*200;
    o.connect(g);
    g.connect(audioCtx.destination);
    g.gain.setValueAtTime(0.0001, now);
    g.gain.exponentialRampToValueAtTime(0.18, now + 0.01);
    g.gain.exponentialRampToValueAtTime(0.0001, now + 0.12);
    o.start(now); o.stop(now + 0.14);
  }

  // coin sound wrapper (redefined to use function above)
  function playCoinSound() {
    if (!audioCtx) ensureAudio();
    const now = audioCtx.currentTime;
    const o = audioCtx.createOscillator();
    const g = audioCtx.createGain();
    o.type = 'square';
    o.frequency.value = 900 + Math.random() * 200;
    o.connect(g);
    g.connect(audioCtx.destination);
    g.gain.setValueAtTime(0.0001, now);
    g.gain.exponentialRampToValueAtTime(0.26, now + 0.006);
    g.gain.exponentialRampToValueAtTime(0.0001, now + 0.16);
    o.start(now); o.stop(now + 0.18);
  }

  // alias playHitSound to this function (makes sound when arrow hits)
  function playHitSound(){ playHitSoundImpl(); }

  // renderUpgrades wrapper used earlier; define now to ensure one consistent implementation
  function renderUpgrades() {
    upgradeListEl.innerHTML = '';
    state.upgrades.forEach(u => {
      const li = document.createElement('li');
      const left = document.createElement('div');
      left.textContent = `${u.name} — Cost: ${u.cost}`;
      const right = document.createElement('div');
      const btn = document.createElement('button');
      btn.className = 'upgrade-btn';
      btn.textContent = 'Buy';
      btn.disabled = Math.floor(state.banked) < u.cost;
      btn.addEventListener('click', () => buyUpgrade(u));
      right.appendChild(btn);
      li.appendChild(left);
      li.appendChild(right);
      upgradeListEl.appendChild(li);
    });
  }

  // Buy upgrade function (final version)
  function buyUpgrade(u) {
    if (Math.floor(state.banked) < u.cost) {
      // optional UI feedback could go here
      return;
    }
    state.banked -= u.cost;
    switch (u.type) {
      case 'idle': state.idleRate += u.amount; break;
      case 'speed': state.player.speed *= u.factor; break;
      case 'life': state.lives += u.amount; break;
      case 'tower':
        // add one tower
        const rect = canvas.getBoundingClientRect();
        const tx = rand(60, rect.width - 60);
        const ty = rand(60, rect.height - 60);
        state.towers.push({ x: tx, y: ty, lastShot: 0 });
        break;
      case 'firerate': state.towerFireRate *= u.factor; break;
      case 'projSpeed': state.towerProjectileSpeed *= u.factor; break;
      case 'range': state.towerRange *= u.factor; break;
    }
    renderUpgrades();
    updateStats();
  }

  // initial UI wiring
  renderUpgrades();
  updateStats();

  // expose some actions for testing in console
  window._ximares = { state, spawnCoin, spawnHazard };

  // ensure initial focus allows keyboard play
  canvas.tabIndex = 0;
  canvas.addEventListener('focus', ()=>{});

  // small startup pre-spawn so the playing area isn't empty on start
  for (let i=0;i<3;i++) spawnCoin();

})();
</script>
</body>
</html>
