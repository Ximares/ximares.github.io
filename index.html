<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
<title>Ximares — Coin Collect Idle (8-bit Funk)</title>
<style>
  :root{
    --bg:#0f1724;
    --card:#0b1220;
    --accent:#ffcb6b;
    --muted:#9aa4b2;
    --glass:rgba(255,255,255,0.06);
    --radius:14px;
  }
  html,body{
    margin:0;
    height:100%;
    background:linear-gradient(180deg,var(--bg) 0%,#071021 100%);
    color:#e6eef8;
    font-family:Inter,system-ui,-apple-system,"Segoe UI",Roboto,Arial,sans-serif;
    -webkit-font-smoothing:antialiased;
  }
  body{
    overflow:auto;
  }
  .wrap{
    min-height:100vh;
    display:flex;
    align-items:center;
    justify-content:center;
    padding:16px;
    box-sizing:border-box;
  }
  .card{
    background:linear-gradient(180deg,var(--card),#050c17);
    border-radius:var(--radius);
    padding:16px;
    width:100%;
    max-width:1000px;
    box-shadow:0 12px 30px rgba(2,6,23,0.7);
    display:grid;
    grid-template-columns:minmax(0,2fr) minmax(0,1.3fr);
    gap:16px;
    max-height:calc(100vh - 32px);
    box-sizing:border-box;
  }
  header h1{margin:0;font-size:20px}
  header p{margin:4px 0 0;color:var(--muted);font-size:13px}

  .game-area{
    background:linear-gradient(180deg,rgba(255,255,255,0.02),transparent);
    border-radius:12px;
    padding:10px;
    display:flex;
    flex-direction:column;
    gap:8px;
  }
  canvas{
    width:100%;
    height:380px;
    background:radial-gradient(circle at 20% 15%,#10253c,#050d18);
    border-radius:10px;
    display:block;
    box-shadow:inset 0 1px 0 rgba(255,255,255,0.04);
    touch-action:none;
  }
  .controls{
    display:flex;
    flex-wrap:wrap;
    gap:8px;
    align-items:center;
    justify-content:flex-start;
  }
  .btn{
    background:var(--glass);
    color:var(--muted);
    border-radius:10px;
    padding:8px 12px;
    font-size:13px;
    border:1px solid rgba(255,255,255,0.06);
    cursor:pointer;
  }
  .btn.primary{
    background:linear-gradient(90deg,#ffdd8a,#ffb84d);
    color:#071021;
    font-weight:700;
  }
  .stats{
    display:flex;
    gap:10px;
    flex-wrap:wrap;
    font-size:13px;
    color:var(--muted);
  }

  .info{
    padding:10px;
    border-radius:10px;
    background:linear-gradient(180deg,rgba(255,255,255,0.01),transparent);
    border:1px solid rgba(255,255,255,0.04);
    color:var(--muted);
    font-size:13px;
  }

  .col-right{
    display:flex;
    flex-direction:column;
    gap:10px;
    overflow:hidden;
  }

  .upgrades-panel{
    flex:1;
    min-height:0;
    display:flex;
    flex-direction:column;
  }
  .upgrades-panel-inner{
    flex:1;
    min-height:0;
    overflow:auto;
  }
  .upgrade-list{
    list-style:none;
    padding:0;
    margin:0;
  }
  .upgrade-list li{
    display:flex;
    justify-content:space-between;
    align-items:center;
    gap:6px;
    padding:6px 0;
    border-bottom:1px solid rgba(255,255,255,0.04);
    font-size:13px;
  }
  .upgrade-btn{
    padding:4px 8px;
    border-radius:8px;
    border:none;
    background:var(--glass);
    color:var(--muted);
    cursor:pointer;
    font-size:12px;
  }
  .upgrade-btn:disabled{
    opacity:0.4;
    cursor:default;
  }

  footer{
    grid-column:1/-1;
    text-align:center;
    color:var(--muted);
    font-size:11px;
    margin-top:4px;
  }

  .scroll-toggle{
    position:fixed;
    top:10px;
    right:10px;
    z-index:9999;
    padding:8px 10px;
    border-radius:10px;
    background:#ffd28c;
    color:#031021;
    border:none;
    font-size:12px;
    font-weight:700;
    box-shadow:0 6px 18px rgba(0,0,0,0.4);
    cursor:pointer;
  }

  /* bottom-sheet upgrades for smaller screenzzz */
  @media (max-width:800px){
    .card{
      grid-template-columns:minmax(0,1fr);
      max-height:none;
      height:auto;
    }
    .col-right{
      position:fixed;
      left:0;
      right:0;
      bottom:0;
      z-index:9000;
    }
    .upgrades-panel{
      max-height:45vh;
      margin:0 10px 10px;
      transition:transform 0.2s ease-out;
      transform:translateY(100%);
    }
    .upgrades-panel.open{
      transform:translateY(0%);
    }
  }

  @media (min-width:801px){
    #toggleUpgrades{
      display:none;
    }
    .upgrades-panel{
      transform:none !important;
    }
  }
</style>
</head>
<body>
<button id="scrollToggle" class="scroll-toggle" aria-pressed="false">Disable Scrolling (Game Mode)</button>

<div class="wrap">
  <main class="card" aria-labelledby="title">
    <div>
      <header>
        <h1 id="title">Ximares — Coin Collect Idle (8-bit Funk)</h1>
        <p>Collect coins, build towers and idle upgrades. Funky 8-bit loop, anime :3 hero, and incremental-style progress.</p>
      </header>

      <section class="game-area" aria-label="Game">
        <canvas id="gameCanvas" width="960" height="540"></canvas>

        <div class="controls">
          <button id="startBtn" class="btn primary">Start / Restart</button>
          <button id="pauseBtn" class="btn">Pause</button>
          <button id="muteBtn" class="btn">Mute Music</button>
          <button id="toggleUpgrades" class="btn">Upgrades (U)</button>
          <div class="stats">
            <span>Score: <strong id="score">0</strong></span>
            <span>Lives: <strong id="lives">3</strong></span>
            <span>Time: <span id="time">0s</span></span>
            <span>Banked: <span id="banked">0</span></span>
          </div>
        </div>

        <div class="info">
          <strong>How to play</strong>
          <p style="margin:4px 0 0">
            Move with Arrow keys / WASD or drag/tap. Collect coins (+10), avoid enemies. Idle upgrades give passive coins.
            Towers shoot enemies — tougher enemies need multiple hits. Press <b>U</b> or tap <b>Upgrades</b> to open the upgrades panel.
          </p>
        </div>
      </section>
    </div>

    <aside class="col-right">
      <section id="upgradesPanel" class="upgrades-panel info">
        <strong>Upgrades & Towers</strong>
        <div class="upgrades-panel-inner">
          <ul id="upgradeList" class="upgrade-list"></ul>
        </div>
      </section>
    </aside>

    <footer>Made for Ximares — Version 1.3 (funky loop, incremental upgrades, towers & HP).</footer>
  </main>
</div>

<script>
(() => {
  /*** DOM ELEMENTS ***/
  const canvas = document.getElementById('gameCanvas');
  const ctx = canvas.getContext('2d');
  const startBtn = document.getElementById('startBtn');
  const pauseBtn = document.getElementById('pauseBtn');
  const muteBtn = document.getElementById('muteBtn');
  const scrollToggle = document.getElementById('scrollToggle');
  const toggleUpgradesBtn = document.getElementById('toggleUpgrades');
  const upgradesPanel = document.getElementById('upgradesPanel');
  const upgradeListEl = document.getElementById('upgradeList');
  const scoreEl = document.getElementById('score');
  const livesEl = document.getElementById('lives');
  const timeEl = document.getElementById('time');
  const bankedEl = document.getElementById('banked');

  /*** AUDIO (8-bit FUNKY LOOP) ***/
  const AudioContext = window.AudioContext || window.webkitAudioContext;
  let audioCtx = null;
  let masterGain = null;
  let musicGain = null;
  let musicBassOsc = null;
  let musicLeadOsc = null;
  let musicStep = 0;
  let musicInterval = null;
  let muted = false;

  function initAudio() {
    if (audioCtx) return;
    audioCtx = new AudioContext();

    masterGain = audioCtx.createGain();
    masterGain.gain.value = 0.6;
    masterGain.connect(audioCtx.destination);

    musicGain = audioCtx.createGain();
    musicGain.gain.value = 0.4;
    musicGain.connect(masterGain);

    createFunkyMusic();
  }

  // 4-bar loop: Gmin9 (2 bars), A7, D7
  // Step length ~0.36s, 16 steps => ~5.76s loop (~4× older one)
  function createFunkyMusic() {
    if (!audioCtx) return;

    if (musicInterval) {
      clearInterval(musicInterval);
      musicInterval = null;
    }

    // Remove previous oscillators if any
    if (musicBassOsc) { musicBassOsc.stop(); musicBassOsc.disconnect(); }
    if (musicLeadOsc) { musicLeadOsc.stop(); musicLeadOsc.disconnect(); }

    musicBassOsc = audioCtx.createOscillator();
    musicBassOsc.type = 'square';
    const bassGain = audioCtx.createGain();
    bassGain.gain.value = 0.22;
    musicBassOsc.connect(bassGain).connect(musicGain);
    musicBassOsc.start();

    musicLeadOsc = audioCtx.createOscillator();
    musicLeadOsc.type = 'square';
    const leadGain = audioCtx.createGain();
    leadGain.gain.value = 0.12;
    musicLeadOsc.connect(leadGain).connect(musicGain);
    musicLeadOsc.start();

    const stepMs = 360;
    musicStep = 0;

    const G2 = 98.0;
    const A2 = 110.0;
    const D2 = 73.42;

    function chordInfo(step) {
      const bar = Math.floor(step / 4); // 0,1,2,3
      if (bar === 0 || bar === 1) return { root: G2, type: 'min9' };
      if (bar === 2) return { root: A2, type: 'dom7' };
      return { root: D2, type: 'dom7' };
    }

    function chordTones(root, type) {
      if (type === 'min9') {
        // roughly Gmin9: G, Bb, D, F, A
        return [
          root,            // G
          root*6/5,        // Bb
          root*3/2,        // D
          root*8/5,        // F-ish
          root*9/5         // A-ish
        ];
      } else {
        // dom7: A7 or D7 -> R, 3, 5, b7
        return [
          root,
          root*5/4,       // major 3rd
          root*3/2,       // 5th
          root*7/4        // b7-ish
        ];
      }
    }

    musicInterval = setInterval(() => {
      if (!audioCtx || audioCtx.state !== 'running') return;
      const now = audioCtx.currentTime;
      const { root, type } = chordInfo(musicStep);
      const tones = chordTones(root, type);

      // "swingy" bass: hit root then 5th, emphasize beats 1 & 3
      const stepInBar = musicStep % 4; // 0..3
      const isDownbeat = (stepInBar === 0 || stepInBar === 2);

      const bassFreq = isDownbeat ? root : tones[2]; // root or 5th
      musicBassOsc.frequency.setValueAtTime(bassFreq, now);

      // little envelope for bass on downbeats
      const bassAccentGain = (isDownbeat ? 1.3 : 0.8);
      bassGain.gain.cancelScheduledValues(now);
      bassGain.gain.setValueAtTime(0.08, now);
      bassGain.gain.linearRampToValueAtTime(0.22*bassAccentGain, now+0.02);
      bassGain.gain.linearRampToValueAtTime(0.10, now+0.28);

      // lead arpeggio across chord tones
      const toneIndex = musicStep % tones.length;
      const leadFreq = tones[toneIndex] * 2; // up an octave
      musicLeadOsc.frequency.setValueAtTime(leadFreq, now);
      // plucky envelope
      leadGain.gain.cancelScheduledValues(now);
      leadGain.gain.setValueAtTime(0.001, now);
      leadGain.gain.exponentialRampToValueAtTime(0.16, now+0.015);
      leadGain.gain.exponentialRampToValueAtTime(0.01, now+0.26);

      musicStep = (musicStep + 1) % 16;
    }, stepMs);
  }

  function setMusicMuted(value) {
    muted = value;
    if (!musicGain) return;
    musicGain.gain.value = muted ? 0 : 0.4;
    muteBtn.textContent = muted ? 'Unmute Music' : 'Mute Music';
  }

  function coinSound() {
    if (!audioCtx) return;
    const t = audioCtx.currentTime;
    const osc = audioCtx.createOscillator();
    const g = audioCtx.createGain();
    osc.type = 'square';
    osc.frequency.setValueAtTime(1400, t);
    osc.frequency.exponentialRampToValueAtTime(500, t+0.12);
    g.gain.setValueAtTime(0.0001, t);
    g.gain.exponentialRampToValueAtTime(0.3, t+0.01);
    g.gain.exponentialRampToValueAtTime(0.0001, t+0.18);
    osc.connect(g).connect(masterGain);
    osc.start(t);
    osc.stop(t+0.2);
  }

  function hitSound() {
    if (!audioCtx) return;
    const t = audioCtx.currentTime;
    const osc = audioCtx.createOscillator();
    const g = audioCtx.createGain();
    osc.type = 'triangle';
    osc.frequency.setValueAtTime(520, t);
    osc.frequency.linearRampToValueAtTime(260, t+0.1);
    g.gain.setValueAtTime(0.001, t);
    g.gain.exponentialRampToValueAtTime(0.22, t+0.01);
    g.gain.exponentialRampToValueAtTime(0.001, t+0.14);
    osc.connect(g).connect(masterGain);
    osc.start(t);
    osc.stop(t+0.16);
  }

  /*** SCROLL TOGGLE ***/
  let scrollingEnabled = true;
  function applyScrollMode() {
    if (scrollingEnabled) {
      document.body.style.overflow = 'auto';
      canvas.style.touchAction = 'auto';
      scrollToggle.textContent = 'Disable Scrolling (Game Mode)';
      scrollToggle.setAttribute('aria-pressed','false');
    } else {
      document.body.style.overflow = 'hidden';
      canvas.style.touchAction = 'none';
      scrollToggle.textContent = 'Enable Scrolling';
      scrollToggle.setAttribute('aria-pressed','true');
    }
  }
  scrollToggle.addEventListener('click', () => {
    scrollingEnabled = !scrollingEnabled;
    applyScrollMode();
  });
  applyScrollMode();

  /*** GAME STATE ***/
  let cw = canvas.width, ch = canvas.height;
  const rectForCanvas = () => canvas.getBoundingClientRect();

  const state = {
    running:false,
    paused:false,
    startTime:0,
    lastFrame:0,
    elapsed:0,
    score:0,
    lives:3,
    banked:0,

    player:{
      x:480,y:270,radius:16,speed:230,
      lastX:480,lastY:270
    },

    coins:[],
    hazards:[],
    towers:[],
    arrows:[],
    trail:[],
    keys:{},
    lastCoinSpawn:0,
    lastHazardSpawn:0,

    idleRate:0,
    coinMultiplier:1,
    hazardRewardMultiplier:1,
    towerFireRate:1.0,
    towerProjectileSpeed:320,
    towerRange:180,

    nextAutoTowerTime:0, // for incremental auto tower upgrade

    upgrades:[
      { id:'idle1',     name:'Idle income +1/s',         cost: 50,  type:'idle',      amount:1 },
      { id:'idle2',     name:'Idle income +5/s',         cost:200,  type:'idle',      amount:5 },
      { id:'speed1',    name:'Speed ×1.25',              cost:120,  type:'speed',     factor:1.25 },
      { id:'life1',     name:'Extra Life +1',            cost:200,  type:'life',      amount:1 },
      { id:'tower1',    name:'Buy tower',                cost:300,  type:'tower' },
      { id:'firerate1', name:'Tower fire rate +20%',     cost:180,  type:'firerate',  factor:1.2 },
      { id:'proj1',     name:'Projectile speed +20%',    cost:150,  type:'projSpeed', factor:1.2 },
      { id:'range1',    name:'Tower range +20%',         cost:200,  type:'range',     factor:1.2 },
      { id:'value1',    name:'Coin value ×2',            cost:400,  type:'coinMult',  factor:2 },
      { id:'bounty1',   name:'Enemy bounty ×2',          cost:350,  type:'bounty',    factor:2 },
      { id:'autotower', name:'Auto tower factory',       cost:600,  type:'autoTower' }
    ]
  };

  /*** UTILITIES ***/
  const rand = (a,b) => Math.random()*(b-a)+a;
  const clamp = (v,a,b) => Math.max(a,Math.min(b,v));
  const dist2 = (A,B) => {
    const dx=A.x-B.x, dy=A.y-B.y;
    return dx*dx+dy*dy;
  };

  function resize() {
    const ratio = window.devicePixelRatio || 1;
    const rectW = Math.min(960, Math.max(320, window.innerWidth - 40));
    const rectH = Math.min(560, Math.max(260, window.innerHeight*0.52));
    canvas.style.width = rectW + 'px';
    canvas.style.height = rectH + 'px';
    cw = rectW*ratio;
    ch = rectH*ratio;
    canvas.width = cw;
    canvas.height = ch;
    ctx.setTransform(ratio,0,0,ratio,0,0);
  }
  window.addEventListener('resize', resize);
  resize();

  /*** INPUT ***/
  window.addEventListener('keydown', e=>{
    const k = e.key.toLowerCase();
    state.keys[k] = true;
    if (k === 'u') {
      toggleUpgrades();
    }
  });
  window.addEventListener('keyup', e=>{
    state.keys[e.key.toLowerCase()] = false;
  });

  let pointerActive = false;
  canvas.addEventListener('pointerdown', e=>{
    if (!audioCtx) { initAudio(); audioCtx.resume && audioCtx.resume().catch(()=>{}); }
    if (!scrollingEnabled){
      pointerActive = true;
      movePlayerToPointer(e);
    }
  }, {passive:false});
  canvas.addEventListener('pointermove', e=>{
    if (pointerActive && !scrollingEnabled){
      movePlayerToPointer(e);
      e.preventDefault();
    }
  }, {passive:false});
  window.addEventListener('pointerup', ()=>pointerActive=false);

  function movePlayerToPointer(e){
    const r = rectForCanvas();
    const x = e.clientX - r.left;
    const y = e.clientY - r.top;
    state.player.x = clamp(x, state.player.radius, r.width - state.player.radius);
    state.player.y = clamp(y, state.player.radius, r.height - state.player.radius);
  }

  /*** SPAWNERS ***/
  function spawnCoin(){
    const r = rectForCanvas();
    state.coins.push({
      x:rand(25,r.width-25),
      y:rand(25,r.height-25),
      radius:8
    });
  }

  function spawnHazard(){
    const r = rectForCanvas();
    const roll = Math.random();
    let hp, radius, color;
    if (roll < 0.6){
      hp = 1; radius = 14; color = '#ff4b4b'; // basic red
    } else if (roll < 0.9){
      hp = 2; radius = 16; color = '#ff9f43'; // orange 2 HP
    } else {
      hp = 3; radius = 18; color = '#a855f7'; // purple 3 HP
    }
    state.hazards.push({
      x:rand(radius,r.width-radius),
      y:rand(radius,r.height-radius),
      vx:rand(-80,80),
      vy:rand(-80,80),
      radius,
      hp,
      maxHp:hp,
      color
    });
  }

  /*** UPGRADES ***/
  function renderUpgrades(){
    upgradeListEl.innerHTML = '';
    state.upgrades.forEach(upg=>{
      const li = document.createElement('li');
      const left = document.createElement('div');
      left.textContent = `${upg.name} — Cost: ${upg.cost}`;
      const right = document.createElement('div');
      const btn = document.createElement('button');
      btn.className = 'upgrade-btn';
      btn.textContent = 'Buy';
      btn.disabled = Math.floor(state.banked) < upg.cost;
      btn.addEventListener('click', ()=>buyUpgrade(upg));
      right.appendChild(btn);
      li.appendChild(left);
      li.appendChild(right);
      upgradeListEl.appendChild(li);
    });
  }

  function buyUpgrade(upg){
    if (Math.floor(state.banked) < upg.cost) return;
    state.banked -= upg.cost;

    switch(upg.type){
      case 'idle':
        state.idleRate += upg.amount;
        break;
      case 'speed':
        state.player.speed *= upg.factor;
        break;
      case 'life':
        state.lives += upg.amount;
        break;
      case 'tower':{
        const r = rectForCanvas();
        const tx = rand(60, r.width-60);
        const ty = rand(60, r.height-60);
        state.towers.push({x:tx,y:ty,lastShot:0});
        break;
      }
      case 'firerate':
        state.towerFireRate *= upg.factor;
        break;
      case 'projSpeed':
        state.towerProjectileSpeed *= upg.factor;
        break;
      case 'range':
        state.towerRange *= upg.factor;
        break;
      case 'coinMult':
        state.coinMultiplier *= upg.factor;
        break;
      case 'bounty':
        state.hazardRewardMultiplier *= upg.factor;
        break;
      case 'autoTower':
        // start auto tower spawns if not already
        if (state.nextAutoTowerTime <= 0) {
          state.nextAutoTowerTime = performance.now() + 20000; // first in 20s
        }
        break;
    }

    renderUpgrades();
    updateStats();
  }

  /*** UPGRADES PANEL TOGGLE (U key + button) ***/
  function toggleUpgrades(){
    if (window.innerWidth <= 800){
      upgradesPanel.classList.toggle('open');
    } else {
      upgradesPanel.scrollIntoView({behavior:'smooth',block:'nearest'});
    }
  }
  toggleUpgradesBtn.addEventListener('click', toggleUpgrades);

  /*** TOWERS & ARROWS ***/
  function towersStep(dt, now){
    // auto tower factory (incremental upgrade)
    if (state.nextAutoTowerTime > 0 && now >= state.nextAutoTowerTime){
      const r = rectForCanvas();
      const tx = rand(60, r.width-60);
      const ty = rand(60, r.height-60);
      state.towers.push({x:tx,y:ty,lastShot:0});
      state.nextAutoTowerTime = now + 20000; // next in 20s
    }

    // towers firing
    for (const t of state.towers){
      let best = null;
      let bestDist = Infinity;
      for (const h of state.hazards){
        const d = dist2(t,h);
        if (d < bestDist && d < state.towerRange*state.towerRange){
          bestDist = d;
          best = h;
        }
      }
      if (!best) continue;
      const cooldownMs = 800 / state.towerFireRate;
      if (now - (t.lastShot || 0) >= cooldownMs){
        t.lastShot = now;
        const ang = Math.atan2(best.y - t.y, best.x - t.x);
        state.arrows.push({
          x:t.x, y:t.y,
          vx:Math.cos(ang)*state.towerProjectileSpeed,
          vy:Math.sin(ang)*state.towerProjectileSpeed,
          radius:5
        });
      }
    }

    // move arrows & damage hazards (1 damage per hit)
    for (let i=state.arrows.length-1;i>=0;i--){
      const a = state.arrows[i];
      a.x += a.vx*dt;
      a.y += a.vy*dt;

      if (a.x < 0 || a.x > canvas.clientWidth ||
          a.y < 0 || a.y > canvas.clientHeight) {
        state.arrows.splice(i,1);
        continue;
      }

      let hit = false;
      for (let j=state.hazards.length-1;j>=0;j--){
        const h = state.hazards[j];
        if (dist2(a,h) < (a.radius + h.radius)**2){
          h.hp -= 1; // 1 damage standard
          if (audioCtx && !muted) hitSound();
          if (h.hp <= 0){
            const reward = 5 * h.maxHp * state.hazardRewardMultiplier;
            state.score += reward;
            state.banked += reward * 0.3; // small extra bank
            state.hazards.splice(j,1);
          }
          state.arrows.splice(i,1);
          hit = true;
          break;
        }
      }
      if (hit) continue;
    }
  }

  /*** UPDATE ***/
  function update(dt, now){
    const p = state.player;
    const prevX = p.x, prevY = p.y;

    let dx=0,dy=0;
    if (state.keys['arrowleft']||state.keys['a']) dx-=1;
    if (state.keys['arrowright']||state.keys['d']) dx+=1;
    if (state.keys['arrowup']||state.keys['w']) dy-=1;
    if (state.keys['arrowdown']||state.keys['s']) dy+=1;
    if (dx!==0 || dy!==0){
      const len = Math.hypot(dx,dy)||1;
      p.x += (dx/len)*p.speed*dt;
      p.y += (dy/len)*p.speed*dt;
    }

    const r = rectForCanvas();
    p.x = clamp(p.x, p.radius, r.width - p.radius);
    p.y = clamp(p.y, p.radius, r.height - p.radius);

    // after-image trail while moving
    const moveDist2 = (p.x-prevX)**2 + (p.y-prevY)**2;
    if (moveDist2 > 1){
      state.trail.push({x:p.x,y:p.y,life:1.0});
    }
    for (let i=state.trail.length-1;i>=0;i--){
      state.trail[i].life -= dt*4;
      if (state.trail[i].life <= 0) state.trail.splice(i,1);
    }

    // hazards movement
    for (const h of state.hazards){
      h.x += h.vx*dt;
      h.y += h.vy*dt;
      if (h.x < h.radius || h.x > canvas.clientWidth - h.radius) h.vx *= -1;
      if (h.y < h.radius || h.y > canvas.clientHeight - h.radius) h.vy *= -1;
    }

    // idle coins
    state.banked += state.idleRate * dt;

    // spawn coins & hazards
    if (now - state.lastCoinSpawn > 900){
      spawnCoin();
      state.lastCoinSpawn = now;
    }
    if (now - state.lastHazardSpawn > 2400){
      spawnHazard();
      state.lastHazardSpawn = now;
    }

    // towers & arrows
    towersStep(dt, now);

    // coin collisions
    for (let i=state.coins.length-1;i>=0;i--){
      const c = state.coins[i];
      if (dist2(p,c) < (p.radius + c.radius)**2){
        state.coins.splice(i,1);
        const gain = 10 * state.coinMultiplier;
        state.score += gain;
        state.banked += gain;
        if (audioCtx && !muted) coinSound();
      }
    }

    // hazard collisions with player
    for (let i=state.hazards.length-1;i>=0;i--){
      const h = state.hazards[i];
      if (dist2(p,h) < (p.radius + h.radius)**2){
        state.hazards.splice(i,1);
        state.lives -= 1;
        if (state.lives <= 0){
          state.running = false;
          alert('Game Over — score: '+Math.floor(state.score)+' banked: '+Math.floor(state.banked));
          if (musicGain) musicGain.gain.value = 0;
        }
      }
    }

    updateStats();
  }

  /*** DRAW ***/
  function draw(){
    ctx.clearRect(0,0,canvas.clientWidth,canvas.clientHeight);

    // trail
    for (const t of state.trail){
      const alpha = t.life * 0.5;
      ctx.beginPath();
      ctx.arc(t.x, t.y, state.player.radius*0.9, 0, Math.PI*2);
      ctx.fillStyle = `rgba(100,200,255,${alpha})`;
      ctx.fill();
    }

    // coins
    for (const c of state.coins){
      ctx.beginPath();
      ctx.arc(c.x,c.y,c.radius,0,Math.PI*2);
      ctx.fillStyle = 'rgba(255,210,90,0.98)';
      ctx.fill();
      ctx.beginPath();
      ctx.arc(c.x-c.radius*0.3,c.y-c.radius*0.3,c.radius*0.4,0,Math.PI*2);
      ctx.fillStyle = 'rgba(255,255,255,0.35)';
      ctx.fill();
    }

    // hazards with HP rings
    for (const h of state.hazards){
      ctx.beginPath();
      ctx.arc(h.x,h.y,h.radius,0,Math.PI*2);
      ctx.fillStyle = h.color;
      ctx.fill();
      if (h.maxHp > 1){
        const frac = h.hp / h.maxHp;
        ctx.beginPath();
        ctx.arc(h.x,h.y,h.radius+3,-Math.PI/2,-Math.PI/2+frac*2*Math.PI);
        ctx.strokeStyle = 'rgba(255,255,255,0.9)';
        ctx.lineWidth = 2;
        ctx.stroke();
      }
    }

    // towers
    for (const t of state.towers){
      ctx.beginPath();
      ctx.arc(t.x,t.y,14,0,Math.PI*2);
      ctx.fillStyle = '#4ea5ff';
      ctx.fill();
      ctx.beginPath();
      ctx.arc(t.x,t.y,state.towerRange,0,Math.PI*2);
      ctx.strokeStyle = 'rgba(78,165,255,0.18)';
      ctx.lineWidth = 1;
      ctx.stroke();
    }

    // arrows
    for (const a of state.arrows){
      ctx.beginPath();
      ctx.arc(a.x,a.y,a.radius,0,Math.PI*2);
      ctx.fillStyle = '#cce6ff';
      ctx.fill();
    }

    // player with anime :3 face
    const p = state.player;
    ctx.beginPath();
    ctx.arc(p.x,p.y,p.radius,0,Math.PI*2);
    ctx.fillStyle = 'rgba(110,210,255,0.98)';
    ctx.fill();

    // eyes
    ctx.fillStyle = '#071021';
    ctx.beginPath(); ctx.arc(p.x-6, p.y-4, 3, 0, Math.PI*2); ctx.fill();
    ctx.beginPath(); ctx.arc(p.x+6, p.y-4, 3, 0, Math.PI*2); ctx.fill();

    // "3" mouth
    ctx.fillStyle = '#071021';
    ctx.font = '10px "Arial", sans-serif';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText('3', p.x, p.y+7);
  }

  /*** STATS ***/
  function updateStats(){
    scoreEl.textContent = Math.floor(state.score);
    livesEl.textContent = state.lives;
    bankedEl.textContent = Math.floor(state.banked);
  }

  /*** LOOP ***/
  function loop(now){
    if (!state.running || state.paused) return;
    if (!state.lastFrame) state.lastFrame = now;
    const dt = Math.min(0.06, (now - state.lastFrame)/1000);
    state.lastFrame = now;
    state.elapsed = now - state.startTime;
    timeEl.textContent = Math.floor(state.elapsed/1000)+'s';

    update(dt, now);
    draw();
    requestAnimationFrame(loop);
  }

  /*** BUTTONS ***/
  startBtn.addEventListener('click', () => {
    if (!audioCtx){ initAudio(); audioCtx.resume && audioCtx.resume().catch(()=>{}); }
    state.running = true;
    state.paused = false;
    state.score = 0;
    state.lives = 3;
    state.banked = 0;
    state.coins = [];
    state.hazards = [];
    state.towers = [];
    state.arrows = [];
    state.trail = [];
    state.idleRate = 0;
    state.coinMultiplier = 1;
    state.hazardRewardMultiplier = 1;
    state.towerFireRate = 1.0;
    state.towerProjectileSpeed = 320;
    state.towerRange = 180;
    state.nextAutoTowerTime = 0;

    const r = rectForCanvas();
    state.player.x = r.width/2;
    state.player.y = r.height/2;
    state.player.lastX = state.player.x;
    state.player.lastY = state.player.y;

    state.startTime = performance.now();
    state.lastFrame = state.startTime;
    state.lastCoinSpawn = 0;
    state.lastHazardSpawn = 0;

    for (let i=0;i<3;i++) spawnCoin();
    spawnHazard();

    renderUpgrades();
    updateStats();
    if (musicGain && !muted) musicGain.gain.value = 0.4;
    requestAnimationFrame(loop);
  });

  pauseBtn.addEventListener('click', () => {
    if (!state.running) return;
    state.paused = !state.paused;
    if (!state.paused){
      state.lastFrame = performance.now();
      if (musicGain && !muted) musicGain.gain.value = 0.4;
      requestAnimationFrame(loop);
    } else {
      if (musicGain) musicGain.gain.value = 0;
    }
  });

  muteBtn.addEventListener('click', () => {
    if (!audioCtx){ initAudio(); audioCtx.resume && audioCtx.resume().catch(()=>{}); }
    setMusicMuted(!muted);
  });

  // initial UI
  renderUpgrades();
  updateStats();
})();
</script>
</body>
</html>
